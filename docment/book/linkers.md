# 第一章

## 1.1 计算机的基本概念

计算机系统由软件和硬件组成。 

最主要的硬件是三个：`CPU` `内存` `I/O`

对称多处理器时代：现在的计算机的CPU都是有多个物理核心的`SMP`

我们见到的软件主要是`application`和`development tools`。

软件是分层的。 
操作系统内核是最底层的，其上是运行时库，然后是应用程序。

    一些重要的概念：
    application
    interface
    run-time-library
    kernel 
    driver 
    hardware

层次之间需要相互通信，这就需要接口。
接口是精心设计的，尽量保持稳定不变。
**应用层程序**编写使用的**应用程序编程接口**(API)是运行时库提供的。
**运行时库**使用的接口是操作系统提供的**系统调用**。
系统调用接口一般以**软件中断**的方式提供。
**驱动程序**是**操作系统内核**的重要组成部分。
操作系统内核使用**硬件接口**提供的服务。
硬件接口的定义决定了驱动程序如何操作硬件。
操作系统和驱动程序的开发者通过阅读**硬件规格**和**硬件编程接口标准**来编写操作系统和驱动程序。

## 1.4 操作系统

操作系统的2个主要功能：`提供抽象的接口`、`管理系统的资源`。

计算机中的资源主要是`计算`、`存储`、`输入输出`。

### 1.4.1 尽量让CPU不要空转

计算资源是不应该被浪费的。

**监控程序**：负责调度准备就绪的程序获得CPU使用权.
这就是多道程序调度策略，是粗糙的策略。

不分轻重缓急是不好的，于是采取主动的策略一段时间之后放弃，这就是分时系统。

    multi programing
    time sharing system
    multi tasking
    process
    preemptive

操作系统接管一切资源，应用程序以进程的方式运行在一个比操作系统权限更低的级别。

操作系统有权暂停一个进程，让另一个进程运行，这就实现了抢占式的内核。

### 1.4.2 设备驱动程序

硬件之间千差万别，应用程序的编写人员不可能直接和硬件打交道。
驱动程序屏蔽了不同硬件之间的差异，硬件被抽象为一系列的概念。

**驱动程序**是内核的一部分，和内核运行在同一特权级别，但是又有一定的独立性。

**文件系统**管理数据在磁盘中的存储方式，是操作系统的重要组成部分。

应用程序要读取硬盘上的数据：
- 应用程序向文件系统发起`read系统调用`，
- 文件系统向硬盘的驱动程序发出请求，
- 驱动程序向硬盘发出`IO命令`

发送IO命令的最常见方式是读写IO寄存器。

## 1.5 内存不够了

如何将计算机上有限的物理内存分配给多个应用程序使用?

### 1.5.1 隔离

直接使用物理内存没有实现隔离、使用的效率低、运行的时候的地址不确定。

虚拟内存解决隔离的问题：每个程序有自己独立的虚拟地址空间。
关键的问题是如何实现虚拟地址和物理地址之间的映射。

### 1.5.2 分段

根据应用程序所需的地址空间的大小直接映射：分段。
分段解决了地址空间隔离的问题和重定位问题。
分段根据程序所需要的地址空间的大小来分割内存，这样粒度太大了，效率比较低。

### 1.5.3 分页

根据局部性原理，我们可以以更细的粒度来对内存进行分割与映射，这就是分页。

页的大小由硬件决定，或者硬件支持多种大小的页，操作系统做出选择。

    虚拟页 virtual page
    物理页 physical page
    磁盘页 disk page

虚拟存储的实现需要硬件的支持：MMU 将虚拟地址翻译成物理地址。

## 1.6 并发与线程

软件并发执行可以发挥多核CPU的性能优势。
多线程是软件并发执行的重要方法。

### 1.6.1 线程

`线程`是程序执行流的最小单元，也被成为轻量级进程。
一个进程由多个线程组成，线程共享进程的地址空间和一些进程级的资源，比如打开文件和信号。

线程私有的一些数据：局部变量，函数的参数、线程局部存储（栈、PC寄存器、线程局部存储数据）。
线程之间共享的进程的资源：全局变量，堆上的数据，函数里的静态变量，程序代码，打开的文件。

线程在SMP上运行可以实现真正的并发执行，但是线程数量多与CPU核心的数量之后就需要线程调度策略。

    thread schedule
    running
    ready
    waiting

线程通常拥有至少三种状态：运行、就绪、等待。
运行中的线程拥有一小段用于执行的时间，成为时间片。`time slice`

- 线程调度

不同操作系统中的线程调度算法，但都融入了优先级调度和轮转法的思想。
在具有优先级的调度系统中，每个线程都有自己的优先级。

线程可以分为：IO密集型线程、CPU密集型线程。

在优先级调度下，可能会出现饿死现象。因此调度系统需要提升过长时间得不到执行的线程的优先级。

线程优先级的改变一般有三种方式：

    用户指定优先级
    根据进入等待状态的频繁程度提升或降低优先级
    长时间得不到执行的线程提升优先级

- 可抢占线程与不可抢占线程

线程在时间片用尽之后，被强制剥夺执行的权力是可以抢占的线程。
早期系统是不可抢占线程，好处是线程调度的时候的执行时机是确定的，可以减少安全问题。

- Linux的多线程

Linux中的所有执行实体都被成为任务。
`task`概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源。

Linux下创建新的任务的系统调用：
    
    fork 复制当前的进程。
    exec 使用新的可执行映像覆盖当前的可执行映像。
    clone 创建子进程并从指定位置开始执行。

fork产生新任务的速度非常快，因为fork并不复制原任务的内存空间，而是和原任务共享一个`写时复制`的内存空间。

### 1.6.2 线程安全

多线程程序在并发时数据的一致性非常重要。
多线程程序处于一个多变的环境之中，可访问的全局变量和堆数据随时都可能被其他的线程改变。

- 竞争与原子操作

单指令的操作可以原子化，这样在执行的时候就不会被打断。
更复杂的数据结构需要使用锁。

- 同步与锁

为了防止多个线程同时读写一个数据而产生不可预料的后果，我们需要对数据进行同步。
同步就是在一个线程访问数据未结束的时候，其他线程不能对这个数据进行访问。

锁是一种非强制的机制，线程在访问资源之前需要获取锁，访问之后释放锁。`lock` `acquire` `release`

二元信号量是最简单的一种锁，只有2个状态：占用和非占用。
适合只能被唯一一个线程独占访问的资源。

对于允许多个线程并发访问的资源，要使用多元信号量。 `semaphore`

互斥量和二元信号量相似，但是获取和释放只能是同一个线程。`mutex`

临界区`critical section`是比互斥量更加严格的同步手段。
互斥量和信号量对系统中的所有线程都是可见的。
临界区的作用范围和可见性仅限与本进程。

对于读取很多，写入很少的资源，使用读写锁来进行同步效率更高。
对于同一个锁，读写锁有两种获取方式，共享的和独占的。

条件变量是一个类似栅栏的同步手段，可以让很多线程同时等待一个事件的发生，事件发生之后，所有的线程可以同时恢复执行。

- 可重入与线程安全 `reentrant` 

一个函数被重入说明函数执行没有完成，被打断了。
可重入函数是重入后不会产生不良后果的函数。
一个可重入的函数可以再多线程环境下放心使用。

- 过度优化

因为编译器和CPU的优化，即使是正确地使用锁，也不一定能保证线程安全。

#### 多线程的内部情况

线程的并发执行是多处理器或操作系统调度来实现的。

用户态的线程和内核线程不是简单的一一对应的关系。

- 三种线程模型

最简单的模型是一对一模型，线程之间的并发也是真正的并发。
Linux中使用clone系统调用创建的线程就是一对一的线程。

多对一的线程模型是将多个用户线程映射到同一个内核线程上。
线程之间的切换由用户代码来执行，切换的速度比一对一线程模型要快得多。
多对一模型减小了上下文切换的开销，提供了近乎无限的线程数量。
但是一个用户进程的阻塞就会造成多个进程的阻塞，增加处理器核的数量也不会对性能提升带来明显帮助。

多对多模型结合了一对一和多对一的特点。

# 第二章 编译和链接

## 2.1 被隐藏的过程
集成开发环境`IDE`
通常把编译和链接合并在一起的过程成为构建：`build`

```shell
    gcc hello.c
```

这个过程可以分解为4个过程：预处理、编译、汇编、链接

`prepressing` `compilation` `assembly` `linking`

### 2.1.1 预编译

预编译器`cpp`将头文件和源文件预编译成一个`i文件`：

```shell
    gcc -E hello.c -o hello.i
```

预编译器主要处理那些源代码中以`#`开头的的预处理指令：`#include` `#define`

预处理的时候加入了文件名和行号，保留了所有的编译器指令：`#prahma`

我们可以通过查看预编译后的文件来确定宏定义展开是否正确，头文件包含是否正确。

### 2.1.2 编译

编译是整个程序构建的核心部分，也是最复杂的部分。

编译过程是把预处理后的文件进行一系列的词法分析、语法分析、语言分析、优化，然后生产出相应的汇编代码文件。

编译原理里面具体介绍了编译过程的理论。可以通过这些命令得到汇编文件：

```shell
    gcc -S hello.i -o hello.s
    gcc -S hello.c -o hello.s
    cc1 hello.c
```

实际上`gcc`是一些后台程序的包装，会根据不同的参数要求去调用预编译编译程序`cc1`、汇编器`as`、链接器`ld`

### 2.1.3 汇编

汇编器将汇编代码翻译成机器可以执行的指令。
没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。

```shell
    as hello.s -o hello.o
    gcc -c hello.s -o hello.o
    gcc -c hello.c -o hello.o
```

### 2.1.4 链接
    
链接将所有的目标文件链接成一个可执行文件。
链接涉及了编译、链接和库的内容，以及操作系统一些很底层的内容。

## 2.2 编译器做了什么

编译器将高级语言翻译成机器语言。

机器语言或者汇编语言编写的程序依赖与特定的机器，完全不具备移植性。

使用自然语言实现程序的缺点是不够精确。

使用数学定义的编程语言就诞生了。

高级语言可以让程序员专心于程序逻辑本身。
高级语言具有很好的移植性和更高的开发效率。

编译的过程一般分为6步：

    词法分析
    语法分析
    语义分析
    源代码优化（语法树的优化）
    代码生成
    目标代码优化（汇编语言的优化）

### 2.2.1 词法分析

对源码程序的第一步处理是进入Scaner，进行词法分析。
运用有限状态自动机的算法可以把源码的字符序列分割成一系列的记号`token`。
扫描器识别出了记号，并且将这些标识符分类放到符号表中。

使用lex程序可以实现词法分析，它会按照用户描述的词法规则将输入的字符串分割成一个一个的记号。

### 2.2.2 语法分析

使用上下文无关语法和下推自动机可以实现语法分析。
语法分析器将扫描器生成的记号构造成语法树。`systax tree`

语法树是以表达式为节点的树。
如果表达式不符合语法规则，编译器会报告语法分析阶段的错误。

语法分析有一个工具叫做yacc: compiler compiler

### 2.2.3 语义分析

语法分析器并不足以判断比如两个指针相乘或者除数为0的错误。
因此需要进行语义分析。

编译器能分析的是静态语义。
静态语义通常包含声明和类型的匹配，类型的转换。

对应的动态语义是运行期间出现的语义相关的问题。

经过语义分析阶段之后，整个语法树的表达式都被标识了类型。
每个表达式，包括符号和数字都被标识了类型。

语义分析器还对符号表里的符号类型也做了更新。

### 2.2.4 中间语言生成

编译器有一个优化过程叫做源码级优化，比如一些在编译期间就能确定值的表达式。

直接在语法树进行优化是复杂的，中间代码是语法分析树的顺序表示。

中间代码一般与目标机器和运行时环境无关。
`中间代码`有很多种类型，主要有`三地址码`和`P-代码`
基本上所有的操作都符合三地址码的形式，优化程序就在三地址码上进行优化。

有了中间代码，编译器可以照此分为前端和后端。
前端负责产生与机器无关的中间代码，后端将中间代码转换为目标机器代码。

### 2.2.5 目标代码的生成与优化

编译器后端主要包括`代码生成器`和`目标代码优化器`。

不同的机器有不同的字长、寄存器、整数数据类型和浮点数据类型。

代码生成器将中间代码转换成依赖机器的目标代码。

目标代码优化器会对生成的目标代码进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算。

编译器具有很复杂的优化过程，现代CPU相当复杂，所以编译器所支持的语言特性与语言标准的规定不一定一致。

优化后的目标代码离可执行还差一步：变量的地址还没有最终确定。
因此链接器要做的任务是把目标文件链接起来生成可执行文件。

## 2.3 链接器比编译器更早出现

最早的程序是写在纸带上的，程序写好之后并不是永不变化的，可能会经常进行修改。

程序中的子程序的地址和跳转指令的地址在程序发生修改之后可能要重新计算。

重新计算地址的过程就是`重定位`。

当程序规模越来越大之后，这种重定位工作变得越来越繁琐和复杂。

汇编语言使用符号和标记来帮助人们记忆指令。
使用符号的方法使得人们从具体的指令地址中解放出来。

`符号`这个概念随着汇编语言的普及迅速被使用，用来表示一段子程序（函数）的起始地址，或者一个变量的地址。

软件的规模逐渐变得庞大，人们开始将代码按照功能或性质划分，形成不同的功能模块。

C语言中，最小的单位是函数和变量。若干个函数和变量组成一个模块，存放在一个.c文件中。

模块之间的组织问题可以归结为模块之间的通信问题。
静态类型的语言C和C++模块之间通信的方式有：模块之间的函数调用、模块之间的变量访问。
函数调用和变量的访问都需要知道函数的入口地址和变量的地址，这就是符号的引用问题。

## 2.4 静态链接

链接器最主要的工作是把一些指令对其他符号地址的引用加以修正。

链接过程主要包括：地址和空间分配、符号决议、重定位。

目标文件和库一起链接成可执行文件。

最常见的库是运行时库，它是支持程序运行的基本函数的集合。

编译器在编译一个.c文件的时候遇到不知道地址的符号会将其搁置，链接器将会修正这些符号的地址。
地址修正的过程就是重定位。



































































