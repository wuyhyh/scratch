在Linux内核中，一致性DMA映射（coherent DMA mapping）和流式DMA映射（streaming DMA mapping）是两种用于在设备和内存之间进行数据传输的DMA映射方式。这两种映射方式在性能、缓存一致性、以及适用场景上有所不同。

### 一致性DMA映射 (Coherent DMA Mapping)

#### 定义
一致性DMA映射是一种确保在CPU和设备之间进行数据传输时，内存区域始终保持缓存一致性的DMA映射方式。

#### 特点
- **缓存一致性**: 在一致性DMA映射下，内存区域与设备共享数据时，内存的缓存一致性由硬件或内核确保。这意味着，CPU和设备都可以安全地访问同一块内存，而不必担心数据不一致的问题。
- **持久性映射**: 这种映射通常是持久的，也就是说，映射一旦建立，就会持续存在，直到显式解除映射。
- **适用场景**: 适用于那些需要频繁访问相同内存区域的DMA操作，比如设备驱动中的环形缓冲区（ring buffers）或描述符表（descriptor tables）。

#### 实现
- 在Linux内核中，可以使用`dma_alloc_coherent()`函数来分配一致性DMA缓冲区。例如：
  ```c
  dma_addr_t dma_handle;
  void *cpu_addr = dma_alloc_coherent(dev, size, &dma_handle, GFP_KERNEL);
  ```
  这会返回一个可以被设备和CPU同时访问的内存区域，`dma_handle`是设备访问该内存的地址。

#### 优点
- **简单**: 由于硬件和内核负责缓存一致性，驱动程序不需要额外的缓存同步操作。
- **安全性**: 适合需要高一致性且不允许数据不一致的操作。

#### 缺点
- **可能的性能损失**: 在某些平台上，为了保持一致性，可能会禁用某些高速缓存，导致性能下降。
- **内存消耗**: 一致性映射的内存不能被其他用途共享，可能导致内存利用率低。

### 流式DMA映射 (Streaming DMA Mapping)

#### 定义
流式DMA映射是一种用于一次性或偶尔的DMA传输的映射方式，适合那些不频繁使用的内存区域。

#### 特点
- **缓存不一致性**: 与一致性DMA映射不同，流式DMA映射不自动保证缓存的一致性。CPU和设备在访问相同的内存区域时，必须手动进行缓存同步操作。
- **短期映射**: 这种映射通常是短期的，即在每次DMA操作前后，内存区域需要重新映射。
- **适用场景**: 适用于那些传输数据量大，但不频繁使用的场景，比如大文件的读取/写入。

#### 实现
- 在Linux内核中，流式DMA映射通常使用`dma_map_single()`或`dma_map_sg()`（用于scatter-gather DMA）来实现。例如：
  ```c
  dma_addr_t dma_handle = dma_map_single(dev, cpu_addr, size, direction);
  ```
  在传输完成后，必须调用`dma_unmap_single()`来解除映射，并确保数据的一致性。

#### 优点
- **灵活性**: 适合那些数据量大、但只需要一次传输的场景，能够提高内存的利用率。
- **缓存性能**: 由于缓存不一致性仅在需要时才处理，通常可以获得更好的缓存性能。

#### 缺点
- **复杂性**: 需要驱动程序显式地管理缓存一致性，可能增加编程复杂性。
- **风险**: 如果缓存同步操作遗漏或错误，可能导致数据不一致或错误。

### 总结

- **一致性DMA映射**:
    - 缓存一致性自动管理。
    - 适合频繁使用的内存区域。
    - 简单但可能有性能损失。

- **流式DMA映射**:
    - 缓存一致性需要手动管理。
    - 适合一次性或偶尔使用的内存区域。
    - 更灵活，适合大数据量传输，但编程复杂度较高。

这两种映射方式各有优劣，选择哪种方式取决于具体的应用场景和性能要求。