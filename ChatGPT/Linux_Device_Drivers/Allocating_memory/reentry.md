在 C 语言中，函数的“可重入性”指的是该函数可以被安全地并发调用，即使在多线程环境下或在函数还没有执行完毕时被再次调用，也不会导致数据不一致、竞态条件或未定义行为。换句话说，可重入函数能够在任意时间点被中断，并且在中断期间或之后又被调用，而不会影响其正确性。

### 可重入函数的特点

1. **不使用静态或全局变量**: 可重入函数不能依赖于静态或全局变量，除非这些变量在每次调用时都可以独立处理，或者通过加锁机制来保证线程安全性。否则，多个线程或多个调用会共享同一个变量，导致数据竞争。

2. **不返回指向静态或全局数据的指针**: 可重入函数不能返回指向静态或全局数据的指针，因为调用者在修改这些数据时可能会影响到其他线程或调用的行为。

3. **使用局部变量**: 可重入函数应尽可能使用局部变量，因为局部变量在每个函数调用中都独立存在，不会在多次调用之间共享。

4. **避免不可重入的函数调用**: 在可重入函数中，不能调用不可重入的函数。例如，`malloc()`、`free()`、`printf()` 等标准库函数通常不可重入，因为它们可能依赖于全局状态或使用了静态数据。

5. **避免依赖非原子操作的共享资源**: 如果函数需要操作共享资源，必须确保这些操作是原子的，即操作不会在中间被中断。或者，需要使用锁机制来保护这些操作，避免多个线程同时访问共享资源。

### 举例说明

#### 不可重入函数示例

```c
#include <stdio.h>

int count_chars(const char *str) {
    static int count = 0;  // 使用静态变量，多个调用会共享同一个 count

    while (*str++) {
        count++;
    }

    return count;
}
```

这个函数不是可重入的，因为它使用了一个静态变量 `count`。如果在函数执行过程中被中断，并且另一个线程或中断处理程序再次调用了 `count_chars()`，会导致 `count` 的值不正确。

#### 可重入函数示例

```c
#include <stdio.h>

int count_chars(const char *str) {
    int count = 0;  // 使用局部变量，确保每次调用都是独立的

    while (*str++) {
        count++;
    }

    return count;
}
```

这个版本的 `count_chars()` 函数是可重入的，因为它只使用了局部变量 `count`。每次函数调用时，`count` 都是独立的，不会与其他线程或其他调用共享数据。

### 总结

可重入函数在多线程编程和信号处理等需要并发调用的场景中非常重要。为了编写可重入函数，需要避免使用全局或静态数据，使用局部变量来存储数据，并避免调用其他不可重入的函数。这样可以确保函数在被多次调用时，能够正确且独立地执行，不会导致数据竞争或不一致的问题。
