在C语言中，字节对齐是一种用于优化内存访问效率的技术，通常由编译器自动处理。对齐规则根据具体的系统架构和编译器实现而有所不同，但一般遵循以下几条原则：

1. 基本对齐规则

   • 每个数据类型的变量的地址应该是该数据类型大小的整数倍。例如：
   • char类型通常占用1字节，不需要对齐，任何地址都可以。
   • short类型通常占用2字节，地址应该是2的倍数。
   • int和float类型通常占用4字节，地址应该是4的倍数。
   • double类型通常占用8字节，地址应该是8的倍数。

2. 结构体的对齐规则

   • 结构体内的每个成员，其地址偏移量应满足该成员的对齐要求。
   • 结构体的起始地址满足结构体中最大基本类型的对齐要求。
   • 结构体的总大小是最大基本类型大小的整数倍（通常是结构体中最大成员类型的大小）。

3. 结构体的填充规则

   • 为了满足对齐要求，编译器可能会在结构体成员之间或结构体结尾添加填充字节，以使每个成员的地址对齐到相应的边界。
   • 结构体末尾的填充字节用于使整个结构体大小对齐到结构体内最大成员的大小。

示例

```c

#include <stdio.h>

struct Example {
	char a;	 // 1字节
	int b;	 // 4字节
	short c; // 2字节
};

int main()
{
	printf("Size of struct Example: %lu\n", sizeof(struct Example));
	return 0;
}

```

内存布局

假设系统对int的对齐要求是4字节，对short的对齐要求是2字节：

	•	char a：占用1字节，位于偏移量0。
	•	int b：为4字节对齐，因此会从偏移量4开始（偏移量1-3会填充3个字节）。
	•	short c：占用2字节，从偏移量8开始。

结构体的总大小是最大对齐要求的整数倍（这里是4字节的整数倍），所以struct Example的大小为12字节（1 + 3 + 4 + 2 + 2）。

常用的对齐控制方法

在一些情况下，我们可以通过编译器指令调整对齐方式：

	•	GCC中的__attribute__((aligned(n)))可以指定对齐字节数。
	•	**#pragma pack(n)**指令可以修改结构体的对齐规则，将对齐方式改为n字节对齐。

总结

	•	每个成员的地址应满足其类型的对齐要求。
	•	结构体的总大小为最大成员对齐大小的整数倍。
	•	编译器可能会在成员之间或结尾添加填充字节，以满足对齐规则。